<!DOCTYPE html>
<head>
	<style type="text/css">
		html, body {
			background-color: transparent;
		}
	</style>
	<link rel="icon" href="data:;base64,iVBORw0KGgo=">
	<script type="text/javascript" src="https://code.jquery.com/jquery-3.4.1.js"></script>
	<script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>

	<script type="text/javascript">
		google.charts.load("current", {packages:["timeline","corechart", "table"]});

		var c_unit = "";
		var c_added_text_entities = [];
		var c_actuator_summary = [];

		var entities = [];
		var max_date = new Date(0);
		var min_date = new Date();
		var unit_types = {};
		var text_type = 0;
		var db_name="";
		
		getDBList();
		getEntities();
		
		function getDBList(e){

			$.ajax(
				{
					url : '/db_list',
					method : 'GET',
					dataType: 'json', // what type of data do we expect back from the server
					encode: true,
					success : function(data){
						UpdateDBList(data);
					},
					error: function(err){
						console.log("DB_List request failed");
					}
				}
			);
		}
		
		function UpdateDBList(db_list)
		{
			for (i = 0; i < db_list.length; i++)
			{
				var optionValue= db_list[i].split(",", 1);
				var optionText= db_list[i]
				$('#db').append(`<option value="${optionValue}">
						${optionText}
					</option>`);
			}
		};
		
		function getEntities()
		{
			$.ajax(
				{
					url : '/get_db',
					method : 'GET',
					dataType: 'json', // what type of data do we expect back from the server
					encode: true,
					success : function(data){
						if ('db_name' in data)
						{
							//console.log("Data received");
							//console.log(data);
							entities=data.entities;
							max_date=new Date(data.max_date);
							min_date=new Date(data.min_date);
							unit_types=data.unit_types;
							text_type=data.text_type;
							db_name=data.db_name;
							c_added_text_entities=data.c_added_text_entities;
							c_unit=data.c_unit;
							//console.log('DB received');
							DrawGraphs(min_date,max_date);
							$("#From").attr({"min" : min_date.toISOString().split('T')[0], "max": max_date.toISOString().split('T')[0]});
							$("#To").attr({"min" : min_date.toISOString().split('T')[0], "max": max_date.toISOString().split('T')[0]});
						}
					},
					error: function(err){
						console.log("DB read failed");
					}
				}
			);
		}
		
		function DrawGraphs(from_date, to_date)
		{
			from_date=new Date(from_date);
			to_date=new Date(to_date);
			//console.log("Let's draw");
			//define from->to dates which makes sense if the fronted selected does not
			if (from_date && to_date)
			{
				from_date.setHours(0);
				from_date.setMinutes(0);
				from_date.setSeconds(0);
				to_date.setHours(23);
				to_date.setMinutes(59);
				to_date.setSeconds(59);
				if (min_date > from_date) {
					from_date = min_date;
				}
				if (max_date < to_date) {
					to_date = max_date;
				}

			} else
			{
				from_date = min_date;
				to_date = max_date;
			}
			// there is selected from->to dates, create the charts' script for the frontend
			if (from_date >= to_date) {
				var this_text_timeline = [];
			} else
			{
				html_text = "The " + db_name + " contains data from " + min_date.toISOString().split('T')[0] + " to " + max_date.toISOString().split('T')[0] + "<BR>\n"
				html_text = html_text+ "Charts created from " + new Date(from_date - (from_date.getTimezoneOffset() * 60000)).toISOString().slice(0, 16) + " to " + new Date(to_date - (to_date.getTimezoneOffset() * 60000)).toISOString().slice(0, 16) + "<BR>\n"
				//console.log("Change HTML object of #db_text to\n " + html_text)
				$("#db_text").empty();
				$("#db_text").html(html_text);
				//filter the text type elements
				this_text_timeline = filter_text_timeline(from_date, to_date);
				//and draw it
				drawChart_timeline(this_text_timeline);
				if (c_unit !== "")
				{
					//filter combochart data
					this_combochart_data=filter_combochart([c_unit, c_added_text_entities], from_date, to_date);
					html_text="<center>";
					for (i = 0; i < c_actuator_summary.length; i++)
					{
						html_text = html_text + c_added_text_entities[0][i] + " was used for " + parseInt(c_actuator_summary[i] / 1000 / 60 / 60) + "h " + new Date(c_actuator_summary[i]).getUTCMinutes() + "min <BR>";
					}
					html_text= html_text + "</center>";
					$("#combo_text").empty();
					$("#combo_text").html(html_text);
					//console.log("combochart_data");
					//console.log(this_combochart_data);
					drawCombo(this_combochart_data,[c_unit, c_added_text_entities]);
					
				}
				get_line_charts(from_date, to_date);
			}
		}
		
		function filter_text_timeline(from_date, to_date)
		{
			from_date = new Date(from_date);
			to_date = new Date(to_date);
			var a_text_timeline = [];
			text_type = 0;
			//go through of all entities
			for (var key in entities)
			{
				var entity = entities[key];
				//if the entity is a text type entity, than create the data
				if (entity.unit === "text")
				{
					//count how many text type element exsits
					text_type = text_type + 1;
					data_used = 0;
					var prevdata = [];
					//if this is not the first entity in the answer, then add a comma
					//if (a_text_timeline.length > 5)
					//{
					//	a_text_timeline = a_text_timeline + ',\n';
					//}
					//and go through on all the data
					for (i = 0; i < entity.data.length; i++)
					{
						adata = entity.data[i];
						//if data is in the required time range
						if (new Date(adata[1]) < to_date && new Date(adata[1]) > from_date)
						{
							//this is the first data from this entity
							if (data_used === 0)
							{
								//this is the firts data of the entity
								if (i === 0)
								{
									//a_text_timeline = a_text_timeline + "\t\t\t\t\t\t[\"" + entity.entity_id + "\",\"" + "unknown" + "\",new Date(" + from_date.getTime() + "),";
									var this_db_row = [entity.entity_id, "unknown", new Date(from_date), new Date(0)];
									a_text_timeline.push(this_db_row);
								}
								//this is not the first data of the entity
								else
								{
									//a_text_timeline = a_text_timeline + "\t\t\t\t\t\t[\"" + entity.entity_id + "\",\"" + prevdata[0] + "\",new Date(" + from_date.getTime() + "),";
									var this_db_row = [entity.entity_id, prevdata[0], new Date(from_date), new Date(0)];
									a_text_timeline.push(this_db_row);
								}
							}
							data_used = 1;
							//finish the previous line, and start the next (the end-date of each data line is in the next measurement data)
							//a_text_timeline = a_text_timeline + "new Date(" + new Date(adata[1]).getTime() + ")],\n\t\t\t\t\t\t[\"" + entity.entity_id + "\",\"" + adata[0] + "\",new Date(" + new Date(adata[1]).getTime() + "),";
							a_text_timeline[a_text_timeline.length -1][3]=new Date(adata[1]);
							var this_db_row = [entity.entity_id, adata[0], new Date(adata[1]), new Date (0)];
							a_text_timeline.push(this_db_row);

						}
						//save the data, it will be required to finish the line
						prevdata = adata;
					}
					//extend the last change of state to end of the requested time
					if (data_used === 1)
					{
						//a_text_timeline = a_text_timeline + "new Date(" + to_date.getTime() + ")]";
						a_text_timeline[a_text_timeline.length -1][3]=new Date(to_date);
					}
				} else
				{

				}
			}
			//close the data array
			//a_text_timeline = a_text_timeline + "]";
			//and clean it up
			//while (a_text_timeline.includes(",\n,"))
			//{
				//a_text_timeline = a_text_timeline.replace(/,\n,/, ",");
			//}
			//console.log(a_text_timeline);
			return a_text_timeline;
		}
		
		function drawChart_timeline(this_text_timeline)
		{
			var data = new google.visualization.DataTable();
			data.addColumn({ type: 'string', id: 'Entity' });
			data.addColumn({ type: 'string', id: 'State' });
			data.addColumn({ type: 'datetime', id: 'Start' });
			data.addColumn({ type: 'datetime', id: 'End' });
			data.addRows(this_text_timeline);
			//console.log("timeline datatable");
			//console.log(this_text_timeline);
			
			//var this_dateformat = google.visualization.DateFormat({pattern: "YYYY-MM-DD hh:mm",timeZone: 1});
			//this_dateformat.format(data,3);
			//this_dateformat.format(data,4);
			var tl_chart = new google.visualization.Timeline(document.getElementById("timeline"));
			var options = {
				chartArea:{left:0,top:0,width:"80%",height:"80%"},
				width: $(window).width()*0.8,
				height: (text_type + 1) * 44,
				legend:{position:'top',alignment:'start'},
				hAxis: {
					title: "Date",
					gridlines: { count: 3, },
					format: "dd-MMM hh:mm"}
			};
			tl_chart.draw(data, options);
		}
		
		//create data for combo chart
		function filter_combochart(identifiers, from_date, to_date)
		{
			from_date = new Date(from_date);
			to_date = new Date(to_date);
			//console.log("To Date:", to_date)
			var timeline_db = [];
			//how many entities are using this unit?
			var unit_used_by = unit_types[identifiers[0]].length;
			//go through the entities
			for (var key in entities)
			{
				var entity = entities[key];
				//if this is an entity that using the specified unit, than collect the data
				if (entity.unit === identifiers[0])// && a_timeline.length<3)
				{
					var leading_text = "";
					var found = 0;
					var tailing_text = "";
					var a_id = 0;
					//create nulls for the other data columns
					for (i = 0; i < unit_used_by + identifiers[1][0].length; i++)
					{
						if (unit_types[identifiers[0]][i] === entity.entity_id)
						{
							found = 1;
							a_id = i;
						} else
						{
							if (found === 0) {
								leading_text = leading_text + "null,";
							}
							if (found === 1) {
								tailing_text = tailing_text + ",null";
							}
						}
					}
					//and go through the data
					for (i = 0; i < entity.data.length; i++)
					{
						adata = entity.data[i];

						//if data is in the required time range
						if (new Date(adata[1]) < to_date && new Date(adata[1]) > from_date)
						{
							if (adata[0] !== "unknown" && adata[0] !== "" && adata[0] !== "None")
							{
								var this_db_row = Array.apply(null, Array(unit_used_by + identifiers[1][0].length + 1)).map(function () {});
								this_db_row[0] = new Date(adata[1]);
								this_db_row[a_id + 1] = parseFloat(adata[0]);
								timeline_db.push(this_db_row);
							}
						}
					}

				}
			}
			for (var key in entities)
			{
				var entity = entities[key];
				//if the unit does not match, but to be shown in the combo chart
				if (identifiers[1][0].includes(entity.entity_id) > 0)
				{
					var identifier_id;
					var leading_text = "";
					var tailing_text = "";
					var found = 0;
					var found_target = 0;
					var a_id = 0;
					//again, create nulls for the other columns
					//first the added entities (not sharing the unit)
					for (i = 0; i < identifiers[1][0].length; i++)
					{
						if (identifiers[1][0][i] === entity.entity_id)
						{
							found = 1;
							identifier_id = i;
							a_id = i + unit_used_by;
						}
					}
					//but also the base entities
					for (i = 0; i < unit_used_by; i++)
					{
						if (unit_types[identifiers[0]][i] === identifiers[1][1][identifier_id])
						{
							found_target = 1;
							b_id = i;
						}
					}
					//console.log("a_id:" + a_id + " b_id:" + b_id)

					//create sum for the actuator active time
					c_actuator_summary[identifier_id] = 0;
					//and browse through the data
					for (i = 0; i < entity.data.length; i++)
					{
						adata = entity.data[i];
						//if this entity is just before the requested interval then push it in
						if (typeof entity.data[i+1] !== 'undefined')
						{
							if (new Date(adata[1]) < from_date && new Date(entity.data[i+1][1]) > from_date)
							{
								adata[1]=new Date(from_date);
							}
						}
						//if data is in the required time range
						if (new Date(adata[1]) < to_date && new Date(adata[1]) >= from_date)
						{
							if (adata[0] !== "unknown" && adata[0] !== "" && adata[0] !== "None" && adata[0] !== "idle" && adata[0] !== "off" && adata[0] !== "unavailable")
							{
								//start_date is found
								var actuator_start = new Date(adata[1]);
								//find end_date
								var actuator_end = new Date(adata[1]);
								var actuator_end_found = 0;
								//seach end date of actuation
								while (actuator_end_found === 0)
								{
									i = i + 1;
									if (typeof entity.data[i] === 'undefined')
									{
										actuator_end = to_date;
										actuator_end_found = 1;
									} else if (entity.data[i][0] !== adata[0])
									{
										actuator_end_found = 1;
										actuator_end = entity.data[i][1];
									}
								}
								if (actuator_end > to_date) {actuator_end= to_date;}
								//revert i with one (if ith is not equal it does not mean if )
								i = i - 1;
								//find start and end values of the corresponding entity
								var start_data = 0;
								var end_data = 0;

								//get the entity which contains the target of the actuation
								for (var akey in entities)
								{
									if (entities[akey].entity_id === identifiers[1][1][identifier_id])
									{
										var this_entity = entities[akey];
									}
								}
								//and search for the collect target value (for the actuation start and end date, might be different)
								for (j = 0; j < this_entity.data.length; j++)
								{
									p_data = this_entity.data[j];
									//as the measurements are asynchronous, before start date collect both start and end dates
									if (new Date(p_data[1]) <= actuator_start) {
										start_data = p_data[0];
										end_data = p_data[0];
									} else if (new Date(p_data[1]) <= actuator_end && new Date(p_data[1]) > actuator_start)
									{
										//after the start date only update the start date
										end_data = p_data[0];
										//except if no data for the start date
										if (start_data === 0) {
											start_data = p_data[0];
										}
									} else
									{
										//and continue till the end if start or end date is not found
										if (start_data === 0) {
											start_data = p_data[0];
										}
										if (end_data === 0) {
											end_data = p_data[0];
										}
									}
								}
								//if possible calculate the start and the end date difference
								if (typeof c_actuator_summary[identifier_id] === 'undefined')
								{
									c_actuator_summary[identifier_id] = actuator_end.getTime() - actuator_start.getTime();
								} else
								{
									c_actuator_summary[identifier_id] = c_actuator_summary[identifier_id] + new Date(actuator_end).getTime() - actuator_start.getTime();
								}

								//create data for the start
								var this_db_row = Array.apply(null, Array(unit_used_by + identifiers[1][0].length + 1)).map(function () {});
								this_db_row[0] = new Date(actuator_start);
								this_db_row[a_id + 1] = parseFloat(start_data);
								timeline_db.push(this_db_row);

								//create data for the end
								var this_db_row = Array.apply(null, Array(unit_used_by + identifiers[1][0].length + 1)).map(function () {});
								this_db_row[0] = new Date(actuator_end);
								this_db_row[a_id + 1] = parseFloat(end_data);
								timeline_db.push(this_db_row);
								//insert null line for the sake of the chart
								var this_db_row = Array.apply(null, Array(unit_used_by + identifiers[1][0].length + 1)).map(function () {});
								this_db_row[0] = new Date(actuator_end);
								timeline_db.push(this_db_row);

								//insert additional data into the original target data for each start and end dates (again, the chart needs it)
								var afound = 0;
								for (j = 0; j < timeline_db.length; j++)
								{
									//if the element is not undefined, we found the right block in the datatable for the current item
									if (typeof timeline_db[j][b_id + 1] !== 'undefined')
									{
										//if (afound ===0)
										//{
										//	console.log(j + ": " + new Date(timeline_db[j][0]).getTime() + " "+ new Date(actuator_start).getTime())
										//}
										afound = 1;
										
										if (new Date(timeline_db[j][0]).getTime() > new Date(actuator_start).getTime())
										{
											var this_db_row = Array.apply(null, Array(unit_used_by + identifiers[1][0].length + 1)).map(function () {});
											this_db_row[0] = new Date(actuator_start);
											this_db_row[b_id + 1] = parseFloat(start_data);
											timeline_db.splice(j, 0, this_db_row);
											afound = 2;
											//console.log("afound")
											break;
										}
									}
									//even if the target entity does not contain data at the specified time (probably no change before)
									else if (afound === 1)
									{
										var this_db_row = Array.apply(null, Array(unit_used_by + identifiers[1][0].length + 1)).map(function () {});
										this_db_row[0] = new Date(actuator_start);
										this_db_row[b_id + 1] = parseFloat(start_data);
										timeline_db.splice(j, 0, this_db_row);
										afound = 2;
										break;
									}
								}
								bfound = 0;
								for (j = 0; j < timeline_db.length; j++)
								{
									//if the element if not undefined, we found the right block in the datatable for the current item
									if (typeof timeline_db[j][b_id + 1] !== 'undefined')
									{
										bfound = 1;
										
										if (new Date(timeline_db[j][0]).getTime() > new Date(actuator_end).getTime())
										{
											var this_db_row = Array.apply(null, Array(unit_used_by + identifiers[1][0].length + 1)).map(function () {});
											this_db_row[0] = new Date(actuator_end);
											this_db_row[b_id + 1] = parseFloat(end_data);
											timeline_db.splice(j, 0, this_db_row);
											afound = 2;
											//console.log("bfound")
											break;
										}
									} else if (bfound === 1)
									{
										var this_db_row = Array.apply(null, Array(unit_used_by + identifiers[1][0].length + 1)).map(function () {});
										this_db_row[0] = new Date(actuator_end);
										this_db_row[b_id + 1] = parseFloat(end_data);
										timeline_db.splice(j, 0, this_db_row);
										afound = 2;
										break;
									}
								}
								//if no measurement found for the target, add it to the beginning of the datatable
								if ((afound === 0) && (bfound === 0))
								{
									var this_db_row = Array.apply(null, Array(unit_used_by + identifiers[1][0].length + 1)).map(function () {});
									this_db_row[0] = new Date(actuator_start);
									this_db_row[b_id + 1] = parseFloat(start_data);
									timeline_db.splice(0, 0, this_db_row);

									var this_db_row = Array.apply(null, Array(unit_used_by + identifiers[1][0].length + 1)).map(function () {});
									this_db_row[0] = new Date(actuator_end);
									this_db_row[b_id + 1] = parseFloat(end_data);
									timeline_db.splice(0, 0, this_db_row);
								}
							}
						}
					}
				}
			}
			//convert to text, and clean up
			//b_timeline = JSON.stringify(timeline_db);
			//b_timeline = b_timeline.replace(/\],\[/g, "],\n\t\t\t\t[");
			//b_timeline = b_timeline.replace(/[0-9]{13}/ig, "new Date($&)");

			//return timeline_db;
			return timeline_db;
		}
		
		//define the function
		function drawCombo(combochart_data, identifiers) 
		{
			var data = new google.visualization.DataTable();
			data.addColumn('datetime','time' );
			//name the columns
			for (i = 0; i < unit_types[identifiers[0]].length; i++)
			{
				data.addColumn('number', unit_types[identifiers[0]][i]);
			}
			for (i = 0; i < identifiers[1][0].length; i++)
			{
				data.addColumn('number', identifiers[1][0][i]);
			}
			//console.log("combochart data");
			//console.log(combochart_data);
			data.addRows(combochart_data);
			var formatNumer = new google.visualization.NumberFormat({pattern: '#.## [\'' + JSON.parse('"' + identifiers[0]+ '"') + '\']', fractionDigits: 2});

			//number formatting
			for (i = 0; i < unit_types[identifiers[0]].length + identifiers[1][0].length; i++)
			{
				var j = i + 1;
				formatNumer.format(data, j );
			}
			//add options general part
			var chart = new google.visualization.ComboChart(document.getElementById("combo1"));
			var options = {
				chart: {subtitle: '[' + identifiers[0] + ']'},
				width: $(window).width()*0.8,
				interpolateNulls: false,
				areaOpacity: 0,
				legend: {position: 'top'},
				hAxis: {title: "Date", format: "dd-MMM hh:mm"},
				seriesType: 'line',
				//series: 
				//{
				//	//add special options for the actuators: type:area
				//	for (i = 0; i < identifiers[1][0].length; i++)
				//	{
				//		i + unit_types[identifiers[0]].length): {type: 'area', areaOpacity: 0.2}";
				//	}
				//} 
			}
			series={};
			for (i = 0; i < identifiers[1][0].length; i++)
			{
				series[(i + unit_types[identifiers[0]].length).toString()] = {type: 'area', areaOpacity: 0.2};
			}
			options.series=series;
			chart.draw(data, options);
		}
		
		function get_line_charts(from_date, to_date)
		{
			$('.chartContainer').empty();
			var script_text = "";
			var div_text = "";
			var count = 0;
			//for each unit
			for (var aunit in unit_types)
			{
				if (count < 100)
				{
					count = count + 1;
					//first the script
					script_text = script_text + draw_linecharts(aunit, from_date, to_date, count);
					//than the frontend location
					//div_text = div_text + "<div id='line" + count + "'></div>\n";
				}
			}
		}

		//create linechart script
		function draw_linecharts(unit, from_date, to_date, count)
		{
			var container = document.createElement('div');
			$('.chartContainer').append(container);
			var data = new google.visualization.DataTable();
			data.addColumn('datetime','time' );
			
			//define columns
			for (i = 0; i < unit_types[unit].length; i++)
			{
				data.addColumn('number', unit_types[unit][i]);
			}
			//add data
			data.addRows(filter_timeline(from_date, to_date, unit));
			var formatNumer = new google.visualization.NumberFormat({pattern: '#.## [\'' + JSON.parse('"' + unit + '"') + '\']', fractionDigits: 2});
			//some number formatting (specially for % data, which does not need 100x multiplication)
			for (i = 0; i < unit_types[unit].length; i++)
			{
				var j = i + 1;
				formatNumer.format(data, j);
			}
			//set some options
			var chart = new google.visualization.LineChart(container);
			var options = {
				chart: {
					subtitle: '[` + unit + `]'
				},
				width: $(window).width()*0.8,
				areaOpacity: 0,
				legend: { 
					position: 'top' 
				},
				hAxis: {
					title: "Date",
					format: "dd-MMM hh:mm"},
			};
			chart.draw(data, options);
		}

		//create data for the numeric timeline charts per unit
		function filter_timeline(from_date, to_date, unit)
		{
			from_date = new Date(from_date);
			to_date = new Date(to_date);
			var timeline_db = [];
			var unit_used_by = unit_types[unit].length;
			//how many entities are using the current unit?
			//go through all entities
			for (var key in entities)
			{
				var entity = entities[key];
				//if the unit matches, than it is a go
				if (entity.unit === unit)// && a_timeline.length<3)
				{
					unit_i = 0;
					//create null elements for the other entities who uses the same unit
					for (i = 0; i < unit_types[unit].length; i++)
					{
						if (unit_types[unit][i] === entity.entity_id)
						{
							unit_i = i;
						} 
					}

					data_used = 0;
					//go through the data of the entity
					for (i = 0; i < entity.data.length; i++)
					{
						adata = entity.data[i];

						//if data is in the required time range
						if (new Date(adata[1]) < to_date && new Date(adata[1]) > from_date)
						{
							if (adata[0] !== "unknown" && adata[0] !== "" && adata[0] !== "None")
							{
								//create data line
								//a_timeline = a_timeline + "\t\t\t\t[new Date(" + new Date(adata[1]).getTime() + ")," + leading_text + adata[0] + tailing_text + "]";
								var this_db_row = Array.apply(null, Array(unit_used_by + 1)).map(function () {});
								this_db_row[0] = new Date(adata[1]);
								this_db_row[unit_i +1] = parseFloat(adata[0]);
								timeline_db.push(this_db_row);
							}
						}
					}
				}
			}
			//clean up the result
			//a_timeline = a_timeline + "]";
			//a_timeline = a_timeline.replace(/,\n,/, ",");

			return timeline_db;
		}
		
	</script>
	
	
</head>
<body>
	<form action="/">
		<select name="Database" id="db">
		</select>
		<input type="submit" value="Select DataBase">
	</form>
	<div id="db_text"></div>
	<form action="javascript:DrawGraphs(new Date(From.value), new Date(To.value))">
		From: <input type="date" name="From" id="From">
		To: <input type="date" name="To" id="To">
		<input type="submit">
	</form>
	<div id="timeline"></div>
	<div id="combo1"></div>
	<div id="combo_text"></div>
	<div class="chartContainer"></div>
</body>
